/*
* Generated by Wasabi. DO NOT EDIT.
* Contains:
*   - independent of program-to-instrument: long.js dependency, Wasabi loader and runtime
*   - generated from program-to-instrument: static information and low-level hooks
*/

const Long = require('./long.js');

/*
 * Wasabi loader (monkey-patches WebAssembly.instantiate()) and runtime (e.g., for resolving call_indirect).
 */

let Wasabi = {
    HOOK_NAMES: [
        "start",
        "if_",
        "br",
        "br_if",
        "br_table",
        "begin",
        "end",
        "nop",
        "unreachable",
        "drop",
        "select",
        "call_pre",
        "call_post",
        "return_",
        "const_",
        "unary",
        "binary",
        "load",
        "store",
        "memory_size",
        "memory_grow",
        "local",
        "global"
    ],

    // map a table index to a function index
    resolveTableIdx: function (tableIdx) {
        if (Wasabi.module.exports === undefined || Wasabi.module.table === undefined) {
            console.warn("cannot resolve table index without exports and table (possible reason: exports and table are not available during Wasm start function)");
            return undefined;
        }

        // FIXME even though MDN says "name property is the toString() result of the function's index in the wasm module"
        // Firefox seems to give out different names :/ -> bug report, either documentation or implementation is wrong
        // see https://developer.mozilla.org/en-US/docs/WebAssembly/Exported_functions

        // dirty HACK subtract the "name index" of the first function, should correct for the wrong property
        // const firstFunctionIdx = parseInt(Wasabi.module.exports[Wasabi.module.info.firstFunctionExportName].name);
        // const functionIdx = parseInt(Wasabi.module.table.get(tableIdx).name) - firstFunctionIdx;
        const functionIdx = parseInt(Wasabi.module.table.get(tableIdx).name);

        return (functionIdx >= Wasabi.module.info.functions.length) ? 0 : functionIdx;
    },

    // call end hooks for all "intermediate" or "implicitly ended blocks" of a branch table
    endBrTableBlocks: function(brTablesInfoIdx, brTableIdx, func) {
        const table = Wasabi.module.info.brTables[brTablesInfoIdx].table;
        const default_ = Wasabi.module.info.brTables[brTablesInfoIdx].default;
        const target = (table[brTableIdx] === undefined) ? default_ : table[brTableIdx];

        // NOTE this is a JavaScript impl of the Wasabi to_end_hook_args() function in Rust
        for (const block of target.ends) {
            const [type, begin, end, begin_if] = block;
            Wasabi.analysis.end(
                {func, instr: end},
                type,
                {func, instr: begin},
                // not undefined only for block type "else"
                (begin_if === undefined) ? undefined : {func, instr: begin_if});
        }
    },

    loc2func: function(loc) {
        // TODO
    },

    loc2instr: function(loc) {
        // TODO
    },

    functionType: function(func) {
        // TODO
    },

    module: {
        // filled at instrumentation time
        // TODO flatten info into module itself, by using Object.assign in generated code
        info: undefined, lowlevelHooks: undefined,
        // filled after instantiation
        exports: undefined, table: undefined,
    },

    // filled by user or with empty hooks (as fallback) before instantiation
    analysis: {}
};

// monkey-patch WebAssembly.instantiate() and .instantiateStreaming() to add Wasabi
{
    // NOTE even though nothing is done with their arguments, we should provide them because it speeds up in Firefox
    // maybe because this way the JIT can inline the functions???
    const defaultHooks = {
        start(location) {},
        nop(location) {},
        unreachable(location) {},
        if_(location, condition) {},
        br(location, target) {},
        br_if(location, conditionalTarget, condition) {},
        br_table(location, table, defaultTarget, tableIdx) {},
        begin(location, type) {},
        end(location, type, beginLocation, ifLocation) {},
        drop(location, value) {},
        select(location, cond, first, second) {},
        call_pre(location, targetFunc, args, indirectTableIdx) {},
        call_post(location, values) {},
        return_(location, values) {},
        const_(location, op, value) {},
        unary(location, op, input, result) {},
        binary(location, op, first, second, result) {},
        load(location, op, memarg, value) {},
        store(location, op, memarg, value) {},
        memory_size(location, currentSizePages) {},
        memory_grow(location, byPages, previousSizePages) {},
        local(location, op, localIndex, value) {},
        global(location, op, globalIndex, value) {},
    }

    const assertInstantiationPrecondition = function() {
        if (Wasabi.module.info === undefined || Wasabi.module.lowlevelHooks === undefined) {
            throw "missing static info or low-level hooks, did you include the Wasabi-generated JavaScript file?";
        }
    }

    const importObjectWithHooks = function(importObject) {
        for (const hook of Wasabi.HOOK_NAMES) {
            if (Wasabi.analysis[hook] === undefined) {
                console.debug(hook, "hook not provided by Wasabi.analysis, add empty function as fallback");
                Wasabi.analysis[hook] = defaultHooks[hook];
            }
        }
        let importObjectWithHooks = importObject || {};
        importObjectWithHooks.__wasabi_hooks = Wasabi.module.lowlevelHooks;
        return importObjectWithHooks;
    }

    const wireInstanceExports = function(instance) {
        Wasabi.module.exports = instance.exports;
        Wasabi.module.table = instance.exports[Wasabi.module.info.tableExportName];
    }

    const oldInstantiate = WebAssembly.instantiate;
    WebAssembly.instantiate = (sourceBuffer, importObject) => {
        assertInstantiationPrecondition();
        const result = oldInstantiate(sourceBuffer, importObjectWithHooks(importObject));
        // as soon as instance is available, save exports and table
        result.then(({module, instance}) => {
            wireInstanceExports(instance);
        });
        return result;
    };

    // just fall-back to regular instantiation since Wasabi doesn't support streaming instrumentation (yet) anyway
    const oldInstantiateStreaming = WebAssembly.instantiateStreaming;
    WebAssembly.instantiateStreaming = async (source, importObject) => {
        let response = await source;
        let buffer = await response.arrayBuffer();
        return WebAssembly.instantiate(buffer, importObject);
    };

    const oldInstance = WebAssembly.Instance;
    const newInstance = function(module, importObject) {
        assertInstantiationPrecondition();
        const instance = new oldInstance(module, importObjectWithHooks(importObject));
        wireInstanceExports(instance);
        return instance;
    };
    WebAssembly.Instance = newInstance;
}

Wasabi.module.info = {"functions":[{"type":"iiiiiiiiii|","import":["env","mapping_callback"],"export":[],"locals":"","instrCount":0},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiiiiiiiiiII","instrCount":386},{"type":"i|","import":null,"export":[],"locals":"iiiiiiiii","instrCount":130},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiii","instrCount":138},{"type":"i|I","import":null,"export":[],"locals":"","instrCount":2},{"type":"i|","import":null,"export":[],"locals":"","instrCount":8},{"type":"ii|","import":null,"export":[],"locals":"","instrCount":2},{"type":"ii|i","import":null,"export":[],"locals":"","instrCount":2},{"type":"i|","import":null,"export":[],"locals":"","instrCount":2},{"type":"i|","import":null,"export":[],"locals":"","instrCount":2},{"type":"i|","import":null,"export":[],"locals":"i","instrCount":29},{"type":"iiii|","import":null,"export":[],"locals":"","instrCount":2},{"type":"iii|","import":null,"export":[],"locals":"","instrCount":2},{"type":"iii|i","import":null,"export":[],"locals":"","instrCount":2},{"type":"iii|i","import":null,"export":[],"locals":"i","instrCount":26},{"type":"iii|i","import":null,"export":[],"locals":"i","instrCount":57},{"type":"ff|i","import":null,"export":["__lesf2","__gesf2","__unordsf2","__eqsf2","__ltsf2","__nesf2","__gtsf2"],"locals":"","instrCount":2},{"type":"FF|i","import":null,"export":["__ledf2","__gedf2","__unorddf2","__eqdf2","__ltdf2","__nedf2","__gtdf2"],"locals":"","instrCount":2},{"type":"i|i","import":null,"export":[],"locals":"iiiiiiiiiII","instrCount":2724},{"type":"ii|","import":null,"export":[],"locals":"iiiii","instrCount":763},{"type":"i|","import":null,"export":[],"locals":"iiiiii","instrCount":885},{"type":"ii|i","import":null,"export":[],"locals":"iiiii","instrCount":200},{"type":"iiiiii|i","import":null,"export":[],"locals":"iiiiiiiI","instrCount":625},{"type":"ii|","import":null,"export":[],"locals":"iiiiiII","instrCount":219},{"type":"i|","import":null,"export":[],"locals":"iiiiii","instrCount":106},{"type":"i|","import":null,"export":[],"locals":"iiiiii","instrCount":106},{"type":"|i","import":null,"export":["get_last_error"],"locals":"i","instrCount":9},{"type":"i|i","import":null,"export":["allocate_mappings"],"locals":"iiiI","instrCount":76},{"type":"i|i","import":null,"export":["parse_mappings"],"locals":"iiiiiiiiiiiiiiiiI","instrCount":941},{"type":"i|","import":null,"export":["free_mappings"],"locals":"ii","instrCount":65},{"type":"i|","import":null,"export":["by_generated_location"],"locals":"iiiiii","instrCount":114},{"type":"i|","import":null,"export":["compute_column_spans"],"locals":"","instrCount":15},{"type":"i|","import":null,"export":["by_original_location"],"locals":"iiiiiiiiiiiiiii","instrCount":417},{"type":"iiii|","import":null,"export":["original_location_for"],"locals":"iiiii","instrCount":258},{"type":"iiiii|","import":null,"export":["generated_location_for"],"locals":"iiiiiii","instrCount":713},{"type":"iiiii|","import":null,"export":["all_generated_locations_for"],"locals":"iiiiiiii","instrCount":547},{"type":"iiiii|","import":null,"export":[],"locals":"iiiiiiiiiiiiiiiiiiiiiiiiiiiiIIIIII","instrCount":4785},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiiiiiiIIIIII","instrCount":459},{"type":"iii|","import":null,"export":[],"locals":"iiiiiiiI","instrCount":306},{"type":"ii|","import":null,"export":[],"locals":"iiiiiii","instrCount":239},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiiiI","instrCount":533},{"type":"iiiii|","import":null,"export":[],"locals":"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiIIIII","instrCount":5125},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiiiiiiiiiiiiIIII","instrCount":666},{"type":"iii|","import":null,"export":[],"locals":"iiiiiiiI","instrCount":321},{"type":"ii|","import":null,"export":[],"locals":"iiiiiiiI","instrCount":578},{"type":"|","import":null,"export":[],"locals":"","instrCount":2}],"globals":"","start":null,"tableExportName":"__wasabi_table","brTables":[]};

Wasabi.module.lowlevelHooks = {
    "begin_function": function (func, instr, ) {
        Wasabi.analysis.begin({func, instr}, "function");
    },
    "i32_store": function (func, instr, offset, align, addr, value) {
        Wasabi.analysis.store({func, instr}, "i32.store", {addr, offset, align}, value);
    },
    "begin_if": function (func, instr, ) {
        Wasabi.analysis.begin({func, instr}, "if");
    },
    "begin_loop": function (func, instr, ) {
        Wasabi.analysis.begin({func, instr}, "loop");
    },
    "i32_store8": function (func, instr, offset, align, addr, value) {
        Wasabi.analysis.store({func, instr}, "i32.store8", {addr, offset, align}, value);
    },
    "begin_block": function (func, instr, ) {
        Wasabi.analysis.begin({func, instr}, "block");
    },
    "i64_store": function (func, instr, offset, align, addr, value_low, value_high) {
        Wasabi.analysis.store({func, instr}, "i64.store", {addr, offset, align}, new Long(value_low, value_high));
    },
    "call_i": function (func, instr, targetFunc, arg0) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0]);
    },
    "call_post": function (func, instr, ) {
        Wasabi.analysis.call_post({func, instr}, []);
    },
    "call_indirect_i": function (func, instr, tableIndex, arg0) {
        Wasabi.analysis.call_pre({func, instr}, Wasabi.resolveTableIdx(tableIndex), [arg0], tableIndex);
    },
    "i32_store16": function (func, instr, offset, align, addr, value) {
        Wasabi.analysis.store({func, instr}, "i32.store16", {addr, offset, align}, value);
    },
    "call_iiiii": function (func, instr, targetFunc, arg0, arg1, arg2, arg3, arg4) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0, arg1, arg2, arg3, arg4]);
    },
    "call_ii": function (func, instr, targetFunc, arg0, arg1) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0, arg1]);
    },
    "call_iiiiii": function (func, instr, targetFunc, arg0, arg1, arg2, arg3, arg4, arg5) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0, arg1, arg2, arg3, arg4, arg5]);
    },
    "call_post_i": function (func, instr, result0) {
        Wasabi.analysis.call_post({func, instr}, [result0]);
    },
    "call_iii": function (func, instr, targetFunc, arg0, arg1, arg2) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0, arg1, arg2]);
    },
    "call_iiiiiiiiii": function (func, instr, targetFunc, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        Wasabi.analysis.call_pre({func, instr}, targetFunc, [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9]);
    },
};

module.exports = Wasabi;
